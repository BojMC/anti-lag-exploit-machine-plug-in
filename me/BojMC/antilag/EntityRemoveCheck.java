package me.BojMC.antilag;

import org.bukkit.*;
import org.bukkit.entity.*;
import java.util.*;

public class EntityRemoveCheck implements Runnable
{
    private Random ran;
    private ArrayList<Entity> ents;
    private ArrayList<Entity> toRemove;
    private ArrayList<Chunk> managed;
    private Callback callback;
    private boolean strict;
    
    public EntityRemoveCheck(final Collection<Entity> entities, final Callback callback, final boolean strict) {
        this.ran = new Random();
        this.ents = new ArrayList<Entity>();
        this.toRemove = new ArrayList<Entity>();
        this.managed = new ArrayList<Chunk>();
        this.callback = callback;
        this.strict = strict;
        this.ents.addAll(entities);
    }
    
    @Override
    public void run() {
        for (final Entity e : this.ents) {
            if (e instanceof Player) {
                continue;
            }
            if (e instanceof Item) {
                this.toRemove.add(e);
            }
            if (e instanceof ArmorStand) {
                continue;
            }
            if (e instanceof ItemFrame) {
                continue;
            }
            if (!(e instanceof LivingEntity)) {
                continue;
            }
            if (this.managed.contains(e.getLocation().getChunk())) {
                continue;
            }
            try {
                if (e.getLocation().getChunk().getEntities().length > 30) {
                    final List<Entity> es = new ArrayList<Entity>(e.getLocation().getChunk().getEntities().length);
                    Entity[] entities;
                    for (int length = (entities = e.getLocation().getChunk().getEntities()).length, i = 0; i < length; ++i) {
                        final Entity n = entities[i];
                        es.add(n);
                    }
                    for (final Entity chunkE : es) {
                        if (this.ran.nextInt(e.getLocation().getChunk().getEntities().length) > 25 && !(chunkE instanceof Player)) {
                            this.toRemove.add(chunkE);
                        }
                    }
                    this.managed.add(e.getLocation().getChunk());
                    continue;
                }
            }
            catch (Exception ex) {}
            if (!this.strict) {
                continue;
            }
            if (e.getType().equals((Object)EntityType.PRIMED_TNT)) {
                this.toRemove.add(e);
            }
            if (e.getType().equals((Object)EntityType.CREEPER)) {
                this.toRemove.add(e);
            }
            if (e.getType().equals((Object)EntityType.SMALL_FIREBALL)) {
                this.toRemove.add(e);
            }
            if (e.getType().equals((Object)EntityType.FIREBALL)) {
                this.toRemove.add(e);
            }
            if (e.getType().equals((Object)EntityType.FALLING_BLOCK)) {
                this.toRemove.add(e);
            }
            if (e.getType().equals((Object)EntityType.GIANT)) {
                this.toRemove.add(e);
            }
            if (e.getType().equals((Object)EntityType.SLIME)) {
                this.toRemove.add(e);
            }
            if (!e.getType().equals((Object)EntityType.FIREWORK)) {
                continue;
            }
            this.toRemove.add(e);
        }
        this.callback.callback(this.toRemove);
    }
    
    public interface Callback
    {
        void callback(final Collection<Entity> p0);
    }
}
